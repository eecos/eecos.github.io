{"meta":{"title":"lijiating’s Blog","subtitle":"凡是挣扎过来的人都是真金不怕火炼的；任何幻灭都不能动摇他们的信仰：因为他们一开始就知道信仰之路和幸福之路全然不同，而他们是不能选选择的，只有往这条路走，别的都是死路。这样的自信不是一朝一夕所能养成的。你绝不能以此期待那些十五岁左右的孩子。在得到这个信念之之前，先得受尽悲痛，流尽眼泪。可是这样是好的，应该要这样……","description":"lijiating’s Blog","author":"李加廷","url":"https://mrjerryli.github.io"},"pages":[{"title":"about","date":"2018-10-30T02:34:36.000Z","updated":"2019-08-11T01:39:47.196Z","comments":true,"path":"about/index.html","permalink":"https://mrjerryli.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T03:37:23.154Z","comments":true,"path":"categories/index.html","permalink":"https://mrjerryli.github.io/categories/index.html","excerpt":"","text":""},{"title":"photo","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T01:39:47.244Z","comments":true,"path":"photo/index.html","permalink":"https://mrjerryli.github.io/photo/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T01:39:47.244Z","comments":true,"path":"tags/index.html","permalink":"https://mrjerryli.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker命令","slug":"docker命令","date":"2020-06-06T16:09:27.000Z","updated":"2020-06-07T17:24:00.185Z","comments":true,"path":"post/a9214619.html","link":"","permalink":"https://mrjerryli.github.io/post/a9214619.html","excerpt":"","text":"docker 图文介绍 docker docker1 docker2 docker3 Docker命令参考资料 Docker文档 https://docs.docker.com 命令格式 1docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt; 选项说明 [] 表示设置选项时可以设置不同的值，并且可以多次使用。 =false表示默认值为false =&quot;&quot;表示默认是为空 帮助文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$ docker --help 用法: docker COMMAND A self-sufficient runtime for containers 选项: --config string Location of client config files (default \"C:\\\\Users\\\\junchow\\\\.docker\") -D, --debug 开启debug模式 -H, --host list Daemon socket(s) to connect to -l, --log-level string 设置日志级别，级别分为debug|info|warn|error|fatal，默认为info。 --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"C:\\\\Users\\\\junchow\\\\.docker\\\\machine\\\\machines\\\\default\\\\ca.pem\") --tlscert string Path to TLS certificate file (default \"C:\\\\Users\\\\junchow\\\\.docker\\\\machine\\\\machines\\\\default\\\\cert.pem\") --tlskey string Path to TLS key file (default \"C:\\\\Users\\\\junchow\\\\.docker\\\\machine\\\\machines\\\\default\\\\key.pem\") --tlsverify Use TLS and verify the remote (default true) -v, --version 终端打印显示版本信息并退出 管理命令: config 管理Docker配置 container 管理容器 image 管理镜像 network 管理网络 node 管理Swarm节点 plugin 管理插件 secret 管理Docker安全 service 管理服务 swarm 管理Swarm集群 system 管理Docker系统 trust Manage trust on Docker images volume 管理卷 命令: attach 将标准输入和标准输出连接到正在运行的容器 build 使用dockerfile文件创建镜像 commit 从容器的修改项中创建新的镜像 cp 将容器的目录或文件复制到本地文件系统中 create 创建一个新的镜像 diff 检查容器文件系统的修改 events 实时输出docker服务器中发生的事件 exec 从外部运行容器内部的命令 export 将容器的文件系统到处为tat文件包 history 显示镜像的历史 images 输出镜像列表 import 从压缩为tar文件的文件系统中创建镜像 info 显示当前系统信息、docker容器与镜像个数、设置信息等 inspect 使用JSON格式显示容器与镜像的详细信息 kill 向容器发送kill信号关闭容器 load 从tar文件或标准输入中加载镜像 login 登录docker注册服务器 logout 退出docker注册服务器 logs 输出容器日志信息 pause 暂停容器中正在运行的所有进程 port 查看容器的端口是否处于开放状态 ps 输出容器列表 pull 从注册服务器中拉取一个镜像或仓库 push 将镜像推送到docker注册服务器 rename 重命名一个容器 restart 重启一个或多个容器 rm 删除一个或多个容器，若没有指定标签则删除lastest标签。 rmi 删除一个或多个镜像，若没有指定标签则删除lastest标签。 run 在一个新容器中中运行命令，用于指定镜像创建容器。 save 将一个或多个镜像保存为tar包 search 从Docker Hub中搜索镜像 start 启动一个或多个已经停止的容器 stats Display a live stream of container(s) resource usage statistics stop 停止一个或多个正在运行的容器 tag 设置镜像标签 top 显示容器中正在运行的进程信息 unpause 重启pause命令暂停的容器 update 更新一个或多个容器的配置 version 显示docker版本信息 wait 等待容器终止然后输出退出码 Run 'docker COMMAND --help' for more information on a command. 容器生命周期docker run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# run用于指定镜像创建容器$ docker run [选项] &lt;镜像名称, id&gt; [命令] [参数]# 选项-d, --detach=false 指定容器运行于前台还是后台，默认为false。-i, --interactive=false 打开标准输入用于控制台交互-t, --tty=false 分配tty设备用来支持终端登录，默认为false。-u, --user=\"\" 指定容器的用户-a, --attach=[] 登录容器，必须是以docker run -d启动的容器。-w, --workdir=\"\" 设置容器的工作目录-c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景下使用。-e, --env=[] 设置环境变量，容器中可使用该环境变量。-m, --memory=\"\" 设置容器的内存上限-p, --public=[] 设置容器暴露的端口-h, --hostname=\"\" 设置容器的主机名-v, --volume=[] 设置容器挂载的存储卷，也就是挂载到容器的某个目录。--volumn-from=[] 给容器挂载其他容器上的卷，也就是挂载到容器的某个目录。--cap-add=[] 添加权限--cap-drop=[] 删除权限--cidfile=\"\" 运行容器后在指定文件中写入容器PID值，这是典型的监控系统的用法。--cpuset=\"\" 设置容器可以使用那些CPU，此参数用来设置容器独占CPU。--device=[] 添加主机设备给容器，相当于设备直通。--dns=[] 设置容器的DNS服务器--dns-search=[] 设置容器的DNS搜索域名，写入到容器的/etc/resolv.conf文件。--env-file=[] 设置环境变量文件，文件格式为每行一个环境变量。--expose=[] 设置容器暴露的端口，即修改镜像的暴露端口。--link=[] 设置容器之间的关联关系，使用其他容器的IP、env等信息。--lxc-conf=[] 设置容器的配置文件，只有在指定--exe-driver=lxc时使用。--name=\"\" 设置容器的名称，可通过名字进行容器管理，links特性需要使用名字。--net=\"bridge\" 容器网络设置--privileged=false 设置容器是否为特权容器，特权容器拥有所有的capabilities。--restart=\"no\" 设置让其停止后的重启策略--rm=false 设置容器停止后自动删除容器，不支持以docker run -d启动的容器。--sig-proxy=true 设置由代理接收并处理信号，但SIGCHLD、SIGSTOP、SIGKILL不能被代理。# 命令-d, --detach Detach模式，默认为守护进程模式，即容器以后台方式运行。--rm=false 若容器内的进程终止则自动删除容器，禁止和-d选项一起使用。--sig-proxy=true 将所有信号传递给进程，非TTY模式也一样，但不能传递SIGCHLD、SIGKILL、SIGSTOP信号。# 运行一个在后台执行的容器，同时使用控制台管理。$ docker run -i -t -d ubuntu:latest# 运行一个带命令且在后台不断执行的容器，不直接展示容器内部信息。$ docker run -d ubuntu:latest ping www.docker.com# 运行一个在后台不断执行的容器，同时带有命令，程序被终止后还能重启继续跑，可用控制台管理。$ docker run -d --restart=always ubuntu:latest ping www.docker.com# 为容器指定一个名字$ docker run -d --name=ubuntu_server ubuntu:latest# 容器暴露80端口并指定宿主机81端口与其通信（宿主机端口:容器端口）$ docker run -d --name=ubuntu -p 81:80 ubuntu:latest# 指定容器内目录与宿主机目录共享（宿主机目录:容器目录）$ docker run -d --name=ubuntu_server -v /home/www:/var/www ubuntu:latest# 设置宿主机与docker的共享目录$ docker run -d -i -t -p 80:80 -v /share/swoft:/var/www/swoft --name swoft swoft/swoft /bin/bash 使用docker run启动容器，docker在后台的标准操作流程： 检查本地是否存在指定的镜像，若不存在则从公有仓库下载。 使用镜像创建并启动容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层。 从宿主机配置的网桥接口中桥接一个虚拟机接口到容器中去 从地址池分配一个IP地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 docker create123456789101112131415161718192021222324252627282930313233343536373839# create 使用指定的镜像创建容器，与run命令不同的是，使用create命令只能创建容器而并不启动。$ docker create [选项] &lt;镜像名称,id&gt; &lt;命令&gt; [参数]# 选项-a, --attach=[] 将标准输入、标准输出、标准错误链接到容器-C, --cpu-shares=0 设置CPU资源分配，默认为1024。-e, --env=[] 向容器设备环境变量，用于传递设置或密码。-h, --hostname=\"\" 设置容器主机名-i, --interactive=false 激活标准输入，即使未与容器连接，也维持标准输入。-m, --memory=\"\" 设置内存限制，格式&lt;数字&gt;&lt;单位&gt;，单位可用b、k、m、g。-P, --publish-all=false 将连接到主机的容器的所有端口暴露在外-p, --publish=[] 将连接到主机的容器的特定端口暴露在外，主要用于暴露web服务器的端口。-t, --tty=false 使用TTY模式，若要使用Bash则必须设置该选项。-u, --user=\"\" 设置容器运行时要使用的Linux用户账户和UID-v, --volume=[] 设置数据卷，设置要与主机共享的目录，不将文件保存到容器而是直接保存到主机，在主机目录后添加:ro与:rw进行读写设置，默认未:rw。-w, --workdir=\"\" 设置容器内部要运行进程的目录-add-host=[] 向容器的/etc/hosts添加主机名与IP地址--cap-add=[] 设置容器中使用的cgroups的特定capablity，若设置为all则使用所有的capablity。--cap-drop=[] 从容器中删除cgroup的特定capablity。--cidfile=\"\" 设置cid文件路径，cid中存储着所创建容器的id。--cpuset=\"\" 在多核CPU中设置要运行容器的核心数--device=[] 添加主机设备到容器，格式为&lt;主机设备&gt;:&lt;容器设备&gt;--dns=[] 设置容器中使用的DNS服务器--dns-search=[] 设置docker中要使用的DNS搜索域--entrypoint=\"\" 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。--env-file=[] 向容器应用设置环境变量文件--expose=[] 仅连接容器的端口和主机，并不暴露在外。--link=[] 进行容器连接，格式 &lt;容器名称&gt;:&lt;别名&gt;--lxc-conf=[] 若使用LXC驱动则可设置LXC选项--name 设置容器名称--net=\"bridge\" 设置容器的网络模式--privileged=false 在容器内部使用主机的所有linux内核功能--restart=\"\" 设置容器内部进程终止时重启策略--security-opt=[] 设置SELinux、AppArmor选项--volumn-from=[] 连接数据卷容器，设置格式未&lt;容器名称,id&gt;:&lt;:ro, :rw&gt;，默认读写设置遵从-v选项的设置。# 使用docker镜像nginx:latest创建一个容器名为ubuntu_serve$ docker create --name ubuntu_serve ubuntu:latest$ docker create -it --name ubuntu_server ubutnu:latest /bin/bash docker start123456# start用于启动容器$ docker start &lt;选项&gt;&lt;容器名称, id&gt;# 选项-a, --attach=false 将标准输入、标准输出、标准错误连接到容器，传递所有信号。-i, --interactive=false 激活标准输入 docker stop12345# stop用于终止容器$ docker stop &lt;选项&gt;&lt;容器名称, id&gt;# 选项-t, --timeout=10 设置终止容器前的等待时间，单位为秒。 docker restart12# restart 用于重启容器$ docker restart [选项] &lt;容器名称, id&gt; docker pause12# pause 用于暂停容器中所有的进程$ docker pause [选项] &lt;容器名称, id&gt; docker unpause12# unpause用于重启使用pause命令暂停的容器$ docker unpause &lt;容器名称, id&gt; docker kill12345678# kill用于杀掉一个运行中的容器，发送SIGKILL信号来停止的主进程。$ docker kill [选项] &lt;容器名称, id&gt;# 选项-s 向容器发送一个信号# 杀死运行中的容器nginx$ docker kill -s KILL nginx docker rm12345678910111213# rm用于删除一个或多个容器$ docker rm [选项] &lt;容器名称,id&gt;# 选项-f 通过SIGKILL信号强制删除一个运行中的容器-l 移除容器间的网路连接而非容器本身-v 删除与容器关联的卷# 强制删除容器test$ docker rm -f test# 删除容器test并删除挂载的数据卷$ docke rm -v test docker exec12345678910# exec 用于在运行中的容器中执行命令$ docker exec [选项] &lt;容器名称, id&gt; &lt;命令&gt; [参数]# 选项-d 分离模式即在后台运行-i 即使没有附加也保持STDIN标准输入打开-t 分配一个伪终端# 在容器test中以交互模式执行容器内/root/test.sh脚本$ docker exec -it test /bin/sh /root/test.sh 容器操作docker ps123456789101112# ps用于输出容器列表$ docker ps &lt;选项&gt;# 选项-a, --all=false 列出所有容器，不带-a则输出当前正在运行的容器。--before=\"\" 列出特定容器创建前的容器，包含停止的容器。-f, --filter=[] 设置输出过滤-l, --latest=false 列出最后创建的容器包含停止的容器-q, --quiet=false 只输出容器的ID$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker top1234# top用户显示容器中正在 运行的进程信息$ docker top &lt;容器名称, id&gt;&lt;ps选项&gt;$ docker top docker attach12# attach 用于将标准输入与标准输出连接到正在运行的容器$ docker attach &lt;选项&gt;&lt;容器名称, id&gt; docker logs1234567891011121314# logs用于获取容器的日志$ docker logs [选项] &lt;容器名称,id&gt;# 选项-f 跟踪日志输出--since 显示某个开始时间的所有日志-t 显示时间戳--tail 仅仅列出最新n条容器日志# 跟踪查看test容器的日志$ docker logs -f test# 查看test容器从2019年4月1日以后的最新10条日志$ docker logs --since=\"2019-04-01\" --tail=10 test 如何动态跟踪并查看myswoft容器的日志详情呢？ 1docker@ ~$: docker logs -tf --details myswoft 如何清理日志文件呢？ Docker日志默认存储位于：/var/lib/docker/containers//*.log 12345678910111213141516171819202122# 在docker中切换为root用户docker@default: ~$ su -i# 查看docker容器的idroot@default: ~$ docker ps -a | grep myswoftd26ff0ff1bc0 swoft/swoft \"php /var/www/swoft/…\" 2 weeks ago Up 22 minutes 0.0.0.0:80-&gt;80/tcp myswoft# 查看容器日志文件大小root@default: ~$ ls -lh $(find /var/lib/docker/containers/ -name *-json.log)-rw-r----- 1 root root 0 May 14 13:32 /var/lib/docker/containers/d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b/d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b-json.log# 进入日志目录root@default: ~$ cd /var/lib/docker/containers/d26ff0ff1bc0dc0221ce5be7f78da96123a0ddbb379ab8befd2d1403f44e820b# 临时清理日志文件root@default: /var.../$ truncate -s 0 /var/lib/docker/containers/&lt;container_id&gt;/*-json.log# 临时清理日志文件root@default: /var../$ cat /dev/null &gt; *-json.log# 使用rm删除日志文件后是需要重启容器的，如果容器运行状态下Linux进程会引用着不会释放磁盘空间。root@default /var/.../$ rm -rf *-json.log docker port12345# port用于列出指定容器的端口映射，或者用于查找将PRIVATE_PORT NAT到面向公众的端口。$ docker port [选项] &lt;容器名称,id&gt; [PRIVATE_PORT[/PROTO]]# 查看test容器的端口映射情况$ docker port test 镜像仓库docker search1234567# search用于在docker hub中搜索镜像$ docker search &lt;选项&gt;&lt;搜索关键词&gt;# 选项--automated=false 只显示由docker hub的automated build创建的镜像--no-trunc=false 显示所有因内容过长而省略的部分-s, --stars=0 显示有特定星级以上的镜像 本地镜像docker images12345678910# images用于输出镜像列表$ docker images &lt;选项&gt;&lt;镜像名称, id&gt;# 选项-a, --all=false 列出所有镜像包含父镜像。-f, --filter=[] 设置输出结果过滤，若设置为dangling=true则仅输出无名镜像。--no-trunc=false 显示所有因内容过长而省略的部分$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE docker rmi123456789# rmi 用于删除镜像，若没有指定标签则会删除latest标签。$ docker rmi &lt;注册名称&gt;/&lt;镜像名称, id&gt;:&lt;标签&gt;# 选项-f, --force=false 强制删除镜像--no-prune=false 不删除不带标签的父级镜像# 删除所有镜像$ docker rm -f $(docker ps -a -q) docker tag12345# tag用于设置镜像标签$ docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址, 用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt;# 选项- f, --force=false 强制设置，即使已拥有标签，如远程仓库设置标签。 docker save12345# save用于将镜像保存为tag包文件$ docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;# 选项-o, --output=\"\" 设置保存时的文件名称 若不设置-o选项，tar包文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称但没有指指定标签，则会将所有标签都保存到一个tar包文件中。 信息查看docker info12345678910111213141516171819202122232425262728293031323334353637383940414243444546# info用于显示当前系统信息、docker容器和镜像数量、设置等信息。$ docker infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 18.09.5Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: trueLogging Driver: json-fileCgroup Driver: cgroupfsPlugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslogSwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: bb71b10fd8f58240ca47fbb579b9d1028eea7c84runc version: 2b18fe1d885ee5083ef9f0838fee39b62d653e30init version: fec3683Security Options: seccomp Profile: defaultKernel Version: 4.14.111-boot2dockerOperating System: Boot2Docker 18.09.5 (TCL 8.2.1)OSType: linuxArchitecture: x86_64CPUs: 1Total Memory: 989.4MiBName: defaultID: 7ST2:CIQM:GLVF:AUF2:QFKR:N2LB:FSO7:V6UJ:5IFN:MQVZ:WK7L:TGSSDocker Root Dir: /mnt/sda1/var/lib/dockerDebug Mode (client): falseDebug Mode (server): falseRegistry: https://index.docker.io/v1/Labels: provider=virtualboxExperimental: falseInsecure Registries: 127.0.0.0/8Live Restore Enabled: false docker version123456789101112131415161718192021# version用户输出docker的版本信息$ docker versionClient: Version: 18.03.0-ce API version: 1.37 Go version: go1.9.4 Git commit: 0520e24302 Built: Fri Mar 23 08:31:36 2018 OS/Arch: windows/amd64 Experimental: false Orchestrator: swarmServer: Docker Engine - Community Engine: Version: 18.09.5 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: e8ff056dbc Built: Thu Apr 11 04:50:00 2019 OS/Arch: linux/amd64 Experimental: false ###批量操作 杀死容器docker kill $(docker ps -a -q) ####停止所有 docker stop $(docker ps-a-q) 删除所有docker rmi $(docker images -q) 强行删除docker rmi --force (docker images | grep doss-api | awk &#39;{print3}&#39;) 查看帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748docker-compose -h# -f 指定使用的 Compose 模板文件# 默认为 docker-compose.yml，可以多次指定。docker-compose -f docker-compose.yml up -d #启动所有容器，-d 将会在后台启动并运行所有的容器docker-compose up -d#停用移除所有容器以及网络相关docker-compose down#查看服务容器的输出docker-compose logs#列出项目中目前的所有容器docker-compose ps#构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名.#例如对于 web 项目中的一个 db 容器，可能是 web_db。#可以随时在项目目录下运行 docker-compose build 来重新构建服务docker-compose build# 不带缓存的构建。docker-compose build --no-cache#拉取服务依赖的镜像docker-compose pull#重启项目中的服务docker-compose restart#删除所有（停止状态的）服务容器。#推荐先执行 docker-compose stop 命令来停止容器。docker-compose rm #在指定服务上执行一个命令。docker-compose run ubuntu ping docker.com#设置指定服务运行的容器个数。通过 service=num 的参数来设置数量docker-compose scale web=3 db=2#启动已经存在的服务容器。docker-compose start#停止已经处于运行状态的容器，但不删除它。#通过 docker-compose start 可以再次启动这些容器。docker-compose stop","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"docker搭建redis集群","slug":"docker搭建redis集群","date":"2020-05-19T03:46:20.000Z","updated":"2020-05-19T03:50:27.627Z","comments":true,"path":"post/1672ce0a.html","link":"","permalink":"https://mrjerryli.github.io/post/1672ce0a.html","excerpt":"","text":"Docker-compose部署redis-cluster集群参考链接：https://www.jianshu.com/p/b7dea62bcd8b 参考镜像：https://github.com/publicisworldwide/docker-stacks/tree/master/oracle-linux/environments/storage/redis-cluster 1.创建数据目录 root@rede:# pwd /data/redis root@rede:# mkdir 700&#123;1..6&#125; ##这个目录和下边yml文件的volumes对应 root@rede:# mkdir 700&#123;1..6&#125;/data root@rede:# ls 7001 7002 7003 7004 7005 7006 docker-compose.yml 2.创建一个docker-compose.yml文件，内容如下： version: '3' services: redis1: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7001/data:/data environment: - REDIS_PORT=7001 redis2: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7002/data:/data environment: - REDIS_PORT=7002 redis3: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7003/data:/data environment: - REDIS_PORT=7003 redis4: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7004/data:/data environment: - REDIS_PORT=7004 redis5: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7005/data:/data environment: - REDIS_PORT=7005 redis6: image: publicisworldwide/redis-cluster network_mode: host restart: always volumes: - /data/redis/7006/data:/data environment: - REDIS_PORT=7006 这里用的别人一个现成的镜像 publicisworldwide/redis-cluster ，自己制作也可以，后续会发布制作过程，不过不建议自己做，有什么需要更改的可以在现有的镜像基础上进行更改之后commit。镜像可以自己下载，也可以等启动服务的时候他自动下载。 这里用的是host网络模式，redis挂载到之前创建的目录下。 如果不想使用主机模式可以文章开头的链接，具体我这里就不写了，自己看。至于docker-compose的安装网上一大堆文章，这里不赘述。 3.创建文件之后，启动服务 root@rede: docker-compose up -d Creating redis_redis1_1 ... done Creating redis_redis5_1 ... done Creating redis_redis4_1 ... done Creating redis_redis3_1 ... done Creating redis_redis6_1 ... done Creating redis_redis2_1 ... done root@rede: docker-compose ps Name Command State Ports --------------------------------------------------------------- redis_redis1_1 /usr/local/bin/entrypoint. ... Up redis_redis2_1 /usr/local/bin/entrypoint. ... Up redis_redis3_1 /usr/local/bin/entrypoint. ... Up redis_redis4_1 /usr/local/bin/entrypoint. ... Up redis_redis5_1 /usr/local/bin/entrypoint. ... Up redis_redis6_1 /usr/local/bin/entrypoint. ... Up 状态都为Up，说明服务均正常启动，如果有状态不正常的容器，看看自己服务器的端口是不是被占用了。 4.redis-cluster集群配置 上述只是启动了6个redis容器，并没有设置集群，随便进入一个redis容器，执行下面的命令，IP替换成自己宿主机的IP root@rede:&#x2F;data&#x2F;redis ▶ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a0c7047c2a0e publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis3_1 f165a7c962ca publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis1_1 8ce8ec23974e publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis4_1 1c37f7b71a21 publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis6_1 810b0ff90710 publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis2_1 e5a38e1cc280 publicisworldwide&#x2F;redis-cluster &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;entr…&quot; 2 minutes ago Up 2 minutes redis_redis5_1 df94ddfb5d1f zookeeper:3.4.11 &quot;&#x2F;docker-entrypoint.…&quot; 20 hours ago Up 20 hours 2888&#x2F;tcp, 3888&#x2F;tcp, 0.0.0.0:2182-&gt;2181&#x2F;tcp zookeeper_2 5eb43213b27a zookeeper:3.4.11 &quot;&#x2F;docker-entrypoint.…&quot; 20 hours ago Up 20 hours 2888&#x2F;tcp, 3888&#x2F;tcp, 0.0.0.0:2183-&gt;2181&#x2F;tcp zookeeper_3 d17a6180907e zookeeper:3.4.11 &quot;&#x2F;docker-entrypoint.…&quot; 20 hours ago Up 20 hours 2888&#x2F;tcp, 0.0.0.0:2181-&gt;2181&#x2F;tcp, 3888&#x2F;tcp zookeeper_1 root@rede:# docker exec -ti d3a904cc0d5a bash root@rede:&#x2F;data# redis-cli --cluster create 192.168.1.100:7001 192.168.1.100:7002 192.168.1.100:7003 192.168.1.100:7004 192.168.1.100:7005 192.168.1.100:7006 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 192.168.1.100:7004 to 192.168.1.100:7001 Adding replica 192.168.1.100:7005 to 192.168.1.100:7002 Adding replica 192.168.1.100:7006 to 192.168.1.100:7003 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [WARNING] Some slaves are in the same host as their master M: 7237efa105ff4246c02da08c0e65c18246755f2f 192.168.1.100:7001 slots:[0-5460] (5461 slots) master M: 241d6eb2abcd9a6d41db5231fcd80fac1d452bee 192.168.1.100:7002 slots:[5461-10922] (5462 slots) master M: 493083f2733bc181295f5b9a9fa9bc6fdf821958 192.168.1.100:7003 slots:[10923-16383] (5461 slots) master S: b60ef6cbea0ae06566d17db4a1b4452e56543419 192.168.1.100:7004 replicates 241d6eb2abcd9a6d41db5231fcd80fac1d452bee S: b48e546e963f694eac91d49b285040bb2bec5513 192.168.1.100:7005 replicates 493083f2733bc181295f5b9a9fa9bc6fdf821958 S: 259de2d6be917e64cdc01604521da45cc1f8d842 192.168.1.100:7006 replicates 7237efa105ff4246c02da08c0e65c18246755f2f Can I set the above configuration? (type &#39;yes&#39; to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join .... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.100:7001) M: 7237efa105ff4246c02da08c0e65c18246755f2f 192.168.1.100:7001 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: 241d6eb2abcd9a6d41db5231fcd80fac1d452bee 192.168.1.100:7002 slots:[5461-10922] (5462 slots) master 1 additional replica(s) M: 493083f2733bc181295f5b9a9fa9bc6fdf821958 192.168.1.100:7003 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: b60ef6cbea0ae06566d17db4a1b4452e56543419 192.168.1.100:7004 slots: (0 slots) slave replicates 241d6eb2abcd9a6d41db5231fcd80fac1d452bee S: 259de2d6be917e64cdc01604521da45cc1f8d842 192.168.1.100:7006 slots: (0 slots) slave replicates 7237efa105ff4246c02da08c0e65c18246755f2f S: b48e546e963f694eac91d49b285040bb2bec5513 192.168.1.100:7005 slots: (0 slots) slave replicates 493083f2733bc181295f5b9a9fa9bc6fdf821958 [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered. 至此，基于docker部署的redis-cluster集群就已经完成","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"DockerCompose搭zookeeper集群","slug":"容器化部署zookeeper","date":"2020-05-17T18:24:08.000Z","updated":"2020-05-17T19:02:29.507Z","comments":true,"path":"post/7b97a5e1.html","link":"","permalink":"https://mrjerryli.github.io/post/7b97a5e1.html","excerpt":"","text":"准备zookeeper镜像 这里使用官方提供的镜像，版本为3.4.11 docker-compose分布式管理组件，具体安装以及使用方法见github项目 准备docker-compose.yml文件 这里要注意下yml语法，key冒号后面有空格 这里采用官方镜像提供默认配置，可根据docker-compose配置说明做调整 version: &#39;3.1&#39; services: zoo1: image: zookeeper:3.4.11 restart: always hostname: zoo1 container_name: zookeeper_1 #domainname: ports: - 2181:2181 volumes: - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo1&#x2F;data:&#x2F;data - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo1&#x2F;datalog:&#x2F;datalog environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1&#x3D;zoo1:2888:3888 server.2&#x3D;zoo2:2888:3888 server.3&#x3D;zoo3:2888:3888 zoo2: image: zookeeper:3.4.11 restart: always hostname: zoo2 container_name: zookeeper_2 ports: - 2182:2181 volumes: - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo2&#x2F;data:&#x2F;data - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo2&#x2F;datalog:&#x2F;datalog environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1&#x3D;zoo1:2888:3888 server.2&#x3D;zoo2:2888:3888 server.3&#x3D;zoo3:2888:3888 zoo3: image: zookeeper:3.4.11 restart: always hostname: zoo3 container_name: zookeeper_3 ports: - 2183:2181 volumes: - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo3&#x2F;data:&#x2F;data - &#x2F;usr&#x2F;local&#x2F;docker_app&#x2F;zookeeper&#x2F;zoo3&#x2F;datalog:&#x2F;datalog environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1&#x3D;zoo1:2888:3888 server.2&#x3D;zoo2:2888:3888 server.3&#x3D;zoo3:2888:3888 docker-compse命令提供了一系列子命令 Define and run multi-container applications with Docker. Usage: docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...] docker-compose -h|--help Options: -f, --file FILE Specify an alternate compose file (default: docker-compose.yml) -p, --project-name NAME Specify an alternate project name (default: directory name) --verbose Show more output --no-ansi Do not print ANSI control characters -v, --version Print version and exit -H, --host HOST Daemon socket to connect to --tls Use TLS; implied by --tlsverify --tlscacert CA_PATH Trust certs signed only by this CA --tlscert CLIENT_CERT_PATH Path to TLS certificate file --tlskey TLS_KEY_PATH Path to TLS key file --tlsverify Use TLS and verify the remote --skip-hostname-check Don't check the daemon's hostname against the name specified in the client certificate (for example if your docker host is an IP address) --project-directory PATH Specify an alternate working directory (default: the path of the Compose file) Commands: build Build or rebuild services bundle Generate a Docker bundle from the Compose file config Validate and view the Compose file create Create services down Stop and remove containers, networks, images, and volumes events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show the Docker-Compose version information 校验指定配置文件正确性，默认配置文件名称docker-compose.yml或docker-compose.yml，我这里使用自定义名称zookeeper-compose.yml 注意：如若需指定配置文件，必须在docker-compose后面指定，不能在config等子命令后面指定，否则无效；如果你使用默认配置文件名称，不需要显式指定-f docker-compose.yml // 查看config命令参数 $ docker-compose -f zookeeper-compose.yml config --help // 校验配置文件，不打印 $ docker-compose -f zookeeper-compose.yml config -q 启动zookeeper集群// -d 后台启动 $ docker-compose -f zookeeper-compose.yml up -d 查看容器启动情况$ docker-compose -f zookeeper-compose.yml ps Name Command State Ports ------------------------------------------------------------------------------------------------- zookeeper_1 /docker-entrypoint.sh zkSe ... Up 0.0.0.0:2181-&gt;2181/tcp, 2888/tcp, 3888/tcp zookeeper_2 /docker-entrypoint.sh zkSe ... Up 0.0.0.0:2182-&gt;2181/tcp, 2888/tcp, 3888/tcp zookeeper_3 /docker-entrypoint.sh zkSe ... Up 0.0.0.0:2183-&gt;2181/tcp, 2888/tcp, 3888/tcp 查看zookeeper集群状态 zoo1 $ docker exec -it zookeeper_1 /bin/sh /zookeeper-3.4.11 # zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower // 这是个follower zoo2 $ docker exec -it zookeeper_2 /bin/sh /zookeeper-3.4.11 # zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: leader // 这是个leader zoo3 $ docker exec -it zookeeper_3 /bin/sh /zookeeper-3.4.11 # zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower // 这也是个follower哦 三个zookeeper服务都正常启动了","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"docker-compose在线升级","slug":"docker-compose在线升级","date":"2020-05-17T04:11:25.000Z","updated":"2020-05-17T04:20:31.071Z","comments":true,"path":"post/b82f2049.html","link":"","permalink":"https://mrjerryli.github.io/post/b82f2049.html","excerpt":"","text":"docker-compose在线升级这个比较简单，就三行命令。 获取最新版本curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 注意： 其中1.23.2是可以更换为最新的版本号 授权 chmod +x /usr/local/bin/docker-compose 查看版本 docker-compose --version 这样就在线升级完成了，比较简单。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"阿里云配置Let’s Encrypt证书","slug":"阿里云配置Let’sEncrypt证书","date":"2020-05-16T20:06:25.000Z","updated":"2020-05-16T21:04:23.861Z","comments":true,"path":"post/7bd4d456.html","link":"","permalink":"https://mrjerryli.github.io/post/7bd4d456.html","excerpt":"","text":"Let’s Encrypt证书申请、阿里云配置Let’s Encrypt证书一、证书申请申请入口：https://letsencrypt.osfipin.com/申请成功，如下： 点击查查，可进行证书的下载 解压后得到六个文件 压缩包文件说明 private.pem 密钥，可更改后缀为key fullchain.crt 完整证书，可更改后缀为pem certificate.pfx IIS和Tomcat使用，秘钥在detail.txt中 certificate.crt 域名证书，一般不用 二、证书安装登录阿里云控制台，打开SSL证书列表 点击上传证书，将证书文件及私钥进行上传 上传完成后，结果如下图，在已签发中可查询的到 阿里云ECS服务器打开443安全组访问规则 SSH进入centos服务器，配置NGINX关于 HTTPS 配置，脚本如下： 在NGINX 配置目录conf下创建文件夹cert mkdir cert 上传申请免费域名的证书及秘钥文件，即fullchain.crt 与 cert/private.pem 编辑nginx.conf文件 # HTTPS server server &#123; listen 443 ssl http2; server_name 你的域名; ssl_certificate cert/fullchain.crt; ssl_certificate_key cert/private.pem; ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; location / &#123; root html; index index.html index.htm; &#125; &#125; 检查NGINX配置文件是否编辑正确，重启NGINX ▶ ./nginx -t nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is ok nginx: configuration file /opt/nginx/conf/nginx.conf test is successful ▶ ./nginx -s reload centos开放443端口，重启防火墙 ▶ firewall-cmd --add-port=443/tcp --permanent ▶ firewall-cmd --reload 到这，安心的放你的HTTPS的网站把，已经大功告成。 注意： 在NGINX配置https时，可能会报错找不到 ssl,原因是在安装NGINX时，没有将ssl模块进行安装，该模块依赖于 openssl openssl-devel，安装脚本如下,随后从新编译安装NGINX就可以了。 yum -y install openssl openssl-devel 缺点就是证书只能维持三个月，不是长久，解决方案为使用脚本定时刷新更新证书，但是阿里云还是需要手工进行配置。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"MAC使用homeBrew安装Redis","slug":"MAC使用homeBrew安装Redis","date":"2019-10-21T16:55:09.000Z","updated":"2019-10-21T16:58:13.026Z","comments":true,"path":"post/63201c18.html","link":"","permalink":"https://mrjerryli.github.io/post/63201c18.html","excerpt":"","text":"MAC使用homeBrew安装Redis一般买了macbook第一件事就是把homeBrew和iterm2装上,它们俩的组合可以实现绝大多数的软件安装。网上有很多教程安装它们的，关于homeBrew的操作命令如下: brew search ** //查找某个软件包 brew list //列出已经安装的软件的包 brew install ** //安装某个软件包,默认安装的是稳定版本 brew uninstall **//卸载某个软件的包 brew upgrade ** //更新某个软件包 brew info ** //查看指定软件包的说明 brew cache clean //清理缓存 现在我们尝试在mac上通过homeBrew安装redis brew search redis //出现如下 ==&gt; Searching local taps... hiredis redis redis-leveldb redis@2.8 redis@3.2 ==&gt; Searching taps on GitHub... homebrew/cask/redis-app ==&gt; Searching blacklisted, migrated and deleted formulae... 安装redis3.2版本 brew install redis@3.2 安装完成提示如下 //把redis的环境变量配置到.zshrc中 If you need to have redis@3.2 first in your PATH run: echo 'export PATH=\"/usr/local/opt/redis@3.2/bin:$PATH\"' &gt;&gt; ~/.zshrc To have launchd start redis@3.2 now and restart at login: //使用launchctl brew启动 brew services start redis@3.2 ### 使用配置文件启动 Or, if you don't want/need a background service you can just run: redis-server /usr/local/etc/redis.conf ==&gt; Summary 🍺 /usr/local/Cellar/redis@3.2/3.2.12: 13 files, 1.7MB /usr/local/etc 下修改redis.config找到daemonize no改成yes 以守护进程的方式启动配置环境变量echo ‘export PATH=”/usr/local/opt/redis@3.2/bin:$PATH”‘ &gt;&gt; ~/.zshrc 启动:brew services start redis@3.2或者使用redis-server /usr/local/etc/redis.conf启动查看进程ps axu | grep redis isole 84721 0.0 0.0 4267768 900 s000 S+ 10:08上午 0:00.00 grep redis isole 84501 0.0 0.0 4309180 1568 ?? Ss 10:06上午 0:00.07 redis-server 127.0.0.1:6379 连接客户端:redis-cli -h 127.0.0.1 -p 6379如下:127.0.0.1:6379&gt; get(“123”) 关闭redis-cli shutdown杀死sudo pkill redis-server 关于redis.conf配置文件的说明 redis默认是前台启动,不是以守护进程的方式进行:daemonize no,把这里修改成yes,就可以让redis以守护进程的方式启动。 当redis使用守护进程方式运行,会默认把pid写入/var/run/reids.pid文件中,可以通过pidfile /var/run/redis.pid进行指定。 端口号指定,这个不用多说了,默认是6379,可以根据需要自己修改。 客户端如果一直连接着不释放的话会自动关闭连接,这是通过timeout 100来设定的,如果设置为0表示不会自动关闭。 设置redis数据库的数量, databases 16 默认是16 既然redis是一个数据库,就代表如果需要连接的话可能需要配置一个密码,默认是不需要密码的。requirepass foobared,客户端在链接时需要通过AUTH命令提供密码。等等还有很多，这里仅仅介绍了一点点的命令，直接修改redis.conf是一个方法,但是还有另外一个方法就是通过命令行去修改。redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME 查看某个配置比如 : 我们要查看daemonize 直接输入redis 127.0.0.1:6379&gt; CONFIG GET daemonize修改的话直接:redis 127.0.0.1:6379&gt;CONFIG SET daemonize yes这样就可以了。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://mrjerryli.github.io/tags/Mac/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"springboot-thymeleaf动态模板生成","slug":"springboot-thymeleaf动态模板生成","date":"2019-10-12T12:13:18.000Z","updated":"2019-10-21T16:56:48.420Z","comments":true,"path":"post/457323eb.html","link":"","permalink":"https://mrjerryli.github.io/post/457323eb.html","excerpt":"","text":"springboot-thymeleaf动态模板生成 thymeleaf动态模板，案例 Map data = new HashMap(); data.put(\"name\", \"jerry\"); data.put(\"email\", email); data.put(\"url\", \"https://www.lijiating.online/\"); data.put(\"secondairePath\", \"myblog\"); data.put(\"requestId\", \"\"); SpringTemplateEngine springTemplateEngine = new SpringTemplateEngine(); StringTemplateResolver stringTemplateResolver = new StringTemplateResolver(); stringTemplateResolver.setCacheable(true); stringTemplateResolver.setTemplateMode(TemplateMode.HTML); springTemplateEngine.setTemplateResolver(stringTemplateResolver) Context context = new Context(); context.setVariables(data); String content = \"&lt;span th:utext=\\\"$&#123;code&#125;\\\"&gt;&lt;/span&gt;\"; String result = springTemplateEngine.process(content, context); pom文件引入： &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; springboot可直接引入： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://mrjerryli.github.io/tags/springboot/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"mac杀死端口","slug":"mac杀死端口","date":"2019-09-19T11:33:06.000Z","updated":"2019-09-19T11:42:16.709Z","comments":true,"path":"post/87630688.html","link":"","permalink":"https://mrjerryli.github.io/post/87630688.html","excerpt":"","text":"Mac 查看端口占用及杀死进程 查看端口占用情况 # jerry in ~ [14:04:53] C:1 $ lsof -i :18088 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 27191 lijiating 287u IPv6 0xcebad4dccbf6e8d1 0t0 TCP *:18088 (LISTEN) 杀死占用端口的进程 # jerry in ~ [14:05:08] $ kill -9 27191","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://mrjerryli.github.io/tags/linux/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"ZooKeeper安装及配置 for Mac","slug":"zookeeper","date":"2019-09-10T13:45:35.000Z","updated":"2019-09-10T14:21:30.996Z","comments":true,"path":"post/3ad834c9.html","link":"","permalink":"https://mrjerryli.github.io/post/3ad834c9.html","excerpt":"","text":"ZooKeeper安装及配置 for Mac 安装 查看brew info zookeeper $ brew info zookeeper zookeeper: stable 3.4.12 (bottled), HEAD Centralized server for distributed coordination of services https://zookeeper.apache.org/ 安装brew install zookeeper $ brew install zookeeper ==&gt; Downloading https://homebrew.bintray.com/bottles/zookeeper-3.4.12.high_sierr ###### ################################################################## 100.0% ==&gt; Pouring zookeeper-3.4.12.high_sierra.bottle.tar.gz ==&gt; Caveats To have launchd start zookeeper now and restart at login: brew services start zookeeper Or, if you don't want/need a background service you can just run: zkServer start 安装后，在/usr/local/etc/zookeeper/ 中可查看配置 $ ls /usr/local/etc/zookeeper/ 安装后，在/usr/local/etc/zookeeper/ 已经有了缺省配置 $ ls /usr/local/etc/zookeeper/ 查看配置文件 $ less -N /usr/local/etc/zookeeper/zoo.cfg 配置文件如下 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=/usr/local/var/run/zookeeper/data # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to \"0\" to disable auto purge feature #autopurge.purgeInterval=1 启动服务 执行命令zkServer $ zkServer ZooKeeper JMX enabled by default Using config: /usr/local/etc/zookeeper/zoo.cfg Usage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125; $ zkServer status ZooKeeper JMX enabled by default Using config: /usr/local/etc/zookeeper/zoo.cfg Error contacting service. It is probably not running. $ zkServer start ZooKeeper JMX enabled by default Using config: /usr/local/etc/zookeeper/zoo.cfg Starting zookeeper ... STARTED 查看zookeeper运行及状态 安装后，可以看到zookeeper提供了zkCli等工具进行. $ zkServer status ZooKeeper JMX enabled by default Using config: /usr/local/etc/zookeeper/zoo.cfg Error contacting service. It is probably not running. 192:~ maerfeifei$ zkServer start ZooKeeper JMX enabled by default Using config: /usr/local/etc/zookeeper/zoo.cfg Starting zookeeper ... STARTED 192:~ maerfeifei$ zkCli Connecting to localhost:2181 Welcome to ZooKeeper! JLine support is enabled WATCHER:: WatchedEvent state:SyncConnected type:None path:null [zk: localhost:2181(CONNECTED) 0]","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://mrjerryli.github.io/tags/zookeeper/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"yarn切换镜像源","slug":"yarn","date":"2019-08-28T08:23:25.000Z","updated":"2019-08-28T08:32:36.881Z","comments":true,"path":"post/c965c636.html","link":"","permalink":"https://mrjerryli.github.io/post/c965c636.html","excerpt":"","text":"1、查看一下当前源 yarn config get registry 2、切换为淘宝源 yarn config set registry https://registry.npm.taobao.org 3、或者切换为自带的 yarn config set registry https://registry.yarnpkg.com","categories":[{"name":"yarn","slug":"yarn","permalink":"https://mrjerryli.github.io/categories/yarn/"}],"tags":[{"name":"web","slug":"web","permalink":"https://mrjerryli.github.io/tags/web/"}],"keywords":[{"name":"yarn","slug":"yarn","permalink":"https://mrjerryli.github.io/categories/yarn/"}]},{"title":"centos","slug":"centos","date":"2019-08-04T23:32:01.000Z","updated":"2019-08-11T03:39:26.557Z","comments":true,"path":"post/cd183338.html","link":"","permalink":"https://mrjerryli.github.io/post/cd183338.html","excerpt":"","text":"CentOS 7 开放3306端口访问 CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。1、关闭firewall：systemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl mask firewalld.service 2、安装iptables防火墙yum install iptables-services -y 3.启动设置防火墙 systemctl enable iptablessystemctl start iptables4.查看防火墙状态 systemctl status iptables 5编辑防火墙，增加端口vi /etc/sysconfig/iptables #编辑防火墙配置文件-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT 或者 -A INPUT -p tcp -m state –state NEW -m tcp –dport 22 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 80 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 3306 -j ACCEPT :wq! #保存退出 3.重启配置，重启系统systemctl restart iptables.service #重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"protobuf","slug":"protobuf","date":"2019-08-03T20:53:47.000Z","updated":"2019-08-11T01:39:47.195Z","comments":true,"path":"post/99fac5be.html","link":"","permalink":"https://mrjerryli.github.io/post/99fac5be.html","excerpt":"","text":"什么是protobuf官方解释：Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. 意思是: Protocol buffers是Google的语言中立，平台中立，可扩展的机制，用于序列化结构化数据 - 类似XML，但更小，更快，更简单。 使用 Protobuf 你可以编写一次结构化数据一次，然后可以使用各种语言工具来生成对应语言的源代码然后简单的读取或者操作数据。 抓重点，语言中立， 工具，源代码 使用从上面的介绍中我们可以看到在使用 Protobuf 的使用需要有一个对应语言的工具，通过工具生成对应的源代码，然后在操作相应结构的数据。下面我们依次看下具体是如何使用的。 首先我们这里采用的是 java 语言，所以要先去下载 Java 对应的工具通过链接https://github.com/protocolbuffers/protobuf/releases/tag/v3.8.0下载 Java 的工具，macOS 可以直接使用brew install protobuf 编写 .proto 文件，在使用 Protobuf 前，我们要编写结构化的数据格式，例如我们这里编写 com-test-model-User.proto 文件 &#x2F;&#x2F;指定版本 syntax &#x3D; &quot;proto2&quot;; &#x2F;&#x2F;定义包名 package com.test.model; &#x2F;&#x2F;定义结构数据 message User &#123; &#x2F;&#x2F;必选字段 第1个属性 required string name &#x3D; 1; &#x2F;&#x2F;必选字段 第2个属性 required int32 age &#x3D; 2; &#x2F;&#x2F;可选字段 第3个属性 optional string comment &#x3D; 3; &#125; 编写完了采用命令protoc --java_out=. ./com-test-model-User.proto，就会在当前路径下生成相应的代码结构。 使用案例public class Test &#123; public static void main(String[] args) throws IOException &#123; UserOuterClass.User.Builder userBuilder = UserOuterClass.User.newBuilder(); userBuilder.setName(\"子悠\"); userBuilder.setAge(18); // userBuilder.setComment(\"this is comment\"); System.out.println(\"\\n**********************序列化*****************************\"); byte[] bytes = userBuilder.build().toByteArray(); System.out.println(\"bytes length is \" + bytes.length); for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.print(bytes[i] + \" \"); &#125; System.out.println(\"\\n**********************反序列化*****************************\"); UserOuterClass.User user = UserOuterClass.User.parseFrom(bytes); System.out.println(user.getName()); &#125; &#125; //运行结果 **********************序列化***************************** bytes length is 10 10 6 -27 -83 -112 -26 -126 -96 16 18 **********************反序列化***************************** 子悠 Process finished with exit code 0 结果分析 可能到现在大家还没有发现什么优秀的地方，那么让我解释下。从运行结果来看，序列化后的是一串数字。很简短的一串数字。我们可以想一下如果这里用的 JSON 格式的序列化的话那么结果应该是{&quot;name&quot;: &quot;子悠&quot;, &quot;age&quot;: 18}，如果是 xml 的话，那就会更长，从这里我们就可以看出 protobuf 的序列化的效果是多么的强大，效率是多么的高。我们知道在网络传输的过程中，压缩效率越高传输效率就越高。 &lt;user&gt; &lt;name&gt;子悠&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/user&gt; protobuf 优缺点 更加简单。 数据体积小 3- 10 倍。 更快的反序列化速度，提高 20 - 100 倍。 可以自动化生成更易于编码方式使用的数据访问类。 总结 简单给大家介绍了 protobuf 的简单使用，更多的详细使用，以及底层压缩原理，感兴趣的朋友可以自己的研究一下。 另外说个题外话 protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据。 有时候就是这样，一个项目或者软件的最终形态并不是当时定义的模样，随着时间的推移产品的方向以及定位都会发生翻天覆地的变化。 附属GitHub项目demo地址","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"netty","slug":"netty","permalink":"https://mrjerryli.github.io/tags/netty/"},{"name":"protobuf","slug":"protobuf","permalink":"https://mrjerryli.github.io/tags/protobuf/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]}]}