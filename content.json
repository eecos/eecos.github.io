{"meta":{"title":"lijiating’s Blog","subtitle":"凡是挣扎过来的人都是真金不怕火炼的；任何幻灭都不能动摇他们的信仰：因为他们一开始就知道信仰之路和幸福之路全然不同，而他们是不能选选择的，只有往这条路走，别的都是死路。这样的自信不是一朝一夕所能养成的。你绝不能以此期待那些十五岁左右的孩子。在得到这个信念之之前，先得受尽悲痛，流尽眼泪。可是这样是好的，应该要这样……","description":"lijiating’s Blog","author":"李加廷","url":"https://mrjerryli.github.io"},"pages":[{"title":"about","date":"2018-10-30T02:34:36.000Z","updated":"2019-08-11T01:39:47.196Z","comments":true,"path":"about/index.html","permalink":"https://mrjerryli.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T03:37:23.154Z","comments":true,"path":"categories/index.html","permalink":"https://mrjerryli.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T01:39:47.244Z","comments":true,"path":"tags/index.html","permalink":"https://mrjerryli.github.io/tags/index.html","excerpt":"","text":""},{"title":"photo","date":"2018-10-30T02:33:58.000Z","updated":"2019-08-11T01:39:47.244Z","comments":true,"path":"photo/index.html","permalink":"https://mrjerryli.github.io/photo/index.html","excerpt":"","text":""}],"posts":[{"title":"DockerCompose搭zookeeper集群","slug":"容器化部署zookeeper","date":"2020-05-17T18:24:08.000Z","updated":"2020-05-17T18:52:27.654Z","comments":true,"path":"post/7b97a5e1.html","link":"","permalink":"https://mrjerryli.github.io/post/7b97a5e1.html","excerpt":"","text":"","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"docker-compose在线升级","slug":"docker-compose在线升级","date":"2020-05-17T04:11:25.000Z","updated":"2020-05-17T04:20:31.071Z","comments":true,"path":"post/b82f2049.html","link":"","permalink":"https://mrjerryli.github.io/post/b82f2049.html","excerpt":"","text":"docker-compose在线升级这个比较简单，就三行命令。 获取最新版本 1curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 注意： 其中1.23.2是可以更换为最新的版本号 {% image 20200517docker-compose在线升级/WX20200517-121523@2x.png '获取最新版本' '' %} 授权 1chmod +x /usr/local/bin/docker-compose 授权 查看版本 1docker-compose --version 获取最新版本 这样就在线升级完成了，比较简单。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://mrjerryli.github.io/categories/Server/Docker/"}]},{"title":"阿里云配置Let’s Encrypt证书","slug":"阿里云配置Let’sEncrypt证书","date":"2020-05-16T20:06:25.000Z","updated":"2020-05-16T21:04:23.861Z","comments":true,"path":"post/7bd4d456.html","link":"","permalink":"https://mrjerryli.github.io/post/7bd4d456.html","excerpt":"","text":"Let’s Encrypt证书申请、阿里云配置Let’s Encrypt证书一、证书申请申请入口：https://letsencrypt.osfipin.com/申请成功，如下： 证书 点击查查，可进行证书的下载 证书下载 解压后得到六个文件 证书解压 压缩包文件说明 private.pem 密钥，可更改后缀为key fullchain.crt 完整证书，可更改后缀为pem certificate.pfx IIS和Tomcat使用，秘钥在detail.txt中 certificate.crt 域名证书，一般不用 二、证书安装登录阿里云控制台，打开SSL证书列表 ssl列表 点击上传证书，将证书文件及私钥进行上传 证书上传 证书上传 上传完成后，结果如下图，在已签发中可查询的到 证书已签发 阿里云ECS服务器打开443安全组访问规则 安全访问规则 SSH进入centos服务器，配置NGINX关于 HTTPS 配置，脚本如下： 在NGINX 配置目录conf下创建文件夹cert 1mkdir cert 上传申请免费域名的证书及秘钥文件，即fullchain.crt 与 cert/private.pem 编辑nginx.conf文件 1234567891011121314151617181920# HTTPS server server &#123; listen 443 ssl http2; server_name 你的域名; ssl_certificate cert/fullchain.crt; ssl_certificate_key cert/private.pem; ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; location / &#123; root html; index index.html index.htm; &#125; &#125; 检查NGINX配置文件是否编辑正确，重启NGINX 1234567▶ ./nginx -t nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx/conf/nginx.conf test is successful▶ ./nginx -s reload centos开放443端口，重启防火墙12345▶ firewall-cmd --add-port=443/tcp --permanent▶ firewall-cmd --reload 到这，安心的放你的HTTPS的网站把，已经大功告成。 注意： 在NGINX配置https时，可能会报错找不到 ssl,原因是在安装NGINX时，没有将ssl模块进行安装，该模块依赖于 openssl openssl-devel，安装脚本如下,随后从新编译安装NGINX就可以了。 yum -y install openssl openssl-devel 缺点就是证书只能维持三个月，不是长久，解决方案为使用脚本定时刷新更新证书，但是阿里云还是需要手工进行配置。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"MAC使用homeBrew安装Redis","slug":"MAC使用homeBrew安装Redis","date":"2019-10-21T16:55:09.000Z","updated":"2019-10-21T16:58:13.026Z","comments":true,"path":"post/63201c18.html","link":"","permalink":"https://mrjerryli.github.io/post/63201c18.html","excerpt":"","text":"MAC使用homeBrew安装Redis一般买了macbook第一件事就是把homeBrew和iterm2装上,它们俩的组合可以实现绝大多数的软件安装。网上有很多教程安装它们的，关于homeBrew的操作命令如下: 1234567brew search ** //查找某个软件包brew list //列出已经安装的软件的包brew install ** //安装某个软件包,默认安装的是稳定版本brew uninstall **//卸载某个软件的包brew upgrade ** //更新某个软件包brew info ** //查看指定软件包的说明brew cache clean //清理缓存 现在我们尝试在mac上通过homeBrew安装redis 1234567 brew search redis //出现如下 ==&gt; Searching local taps...hiredis redis redis-leveldb redis@2.8 redis@3.2==&gt; Searching taps on GitHub...homebrew/cask/redis-app==&gt; Searching blacklisted, migrated and deleted formulae... 安装redis3.2版本 1brew install redis@3.2 安装完成提示如下 12345678910111213//把redis的环境变量配置到.zshrc中If you need to have redis@3.2 first in your PATH run: echo 'export PATH=\"/usr/local/opt/redis@3.2/bin:$PATH\"' &gt;&gt; ~/.zshrcTo have launchd start redis@3.2 now and restart at login://使用launchctl brew启动 brew services start redis@3.2 ### 使用配置文件启动Or, if you don't want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis@3.2/3.2.12: 13 files, 1.7MB /usr/local/etc 下修改redis.config找到daemonize no改成yes 以守护进程的方式启动配置环境变量echo ‘export PATH=”/usr/local/opt/redis@3.2/bin:$PATH”‘ &gt;&gt; ~/.zshrc 启动:brew services start redis@3.2或者使用redis-server /usr/local/etc/redis.conf启动查看进程ps axu | grep redis 12isole 84721 0.0 0.0 4267768 900 s000 S+ 10:08上午 0:00.00 grep redisisole 84501 0.0 0.0 4309180 1568 ?? Ss 10:06上午 0:00.07 redis-server 127.0.0.1:6379 连接客户端:redis-cli -h 127.0.0.1 -p 6379如下:127.0.0.1:6379&gt; get(“123”) 关闭redis-cli shutdown杀死sudo pkill redis-server 关于redis.conf配置文件的说明 redis默认是前台启动,不是以守护进程的方式进行:daemonize no,把这里修改成yes,就可以让redis以守护进程的方式启动。 当redis使用守护进程方式运行,会默认把pid写入/var/run/reids.pid文件中,可以通过pidfile /var/run/redis.pid进行指定。 端口号指定,这个不用多说了,默认是6379,可以根据需要自己修改。 客户端如果一直连接着不释放的话会自动关闭连接,这是通过timeout 100来设定的,如果设置为0表示不会自动关闭。 设置redis数据库的数量, databases 16 默认是16 既然redis是一个数据库,就代表如果需要连接的话可能需要配置一个密码,默认是不需要密码的。requirepass foobared,客户端在链接时需要通过AUTH命令提供密码。等等还有很多，这里仅仅介绍了一点点的命令，直接修改redis.conf是一个方法,但是还有另外一个方法就是通过命令行去修改。redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME 查看某个配置比如 : 我们要查看daemonize 直接输入redis 127.0.0.1:6379&gt; CONFIG GET daemonize修改的话直接:redis 127.0.0.1:6379&gt;CONFIG SET daemonize yes这样就可以了。","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://mrjerryli.github.io/tags/Mac/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"springboot-thymeleaf动态模板生成","slug":"springboot-thymeleaf动态模板生成","date":"2019-10-12T12:13:18.000Z","updated":"2019-10-21T16:56:48.420Z","comments":true,"path":"post/457323eb.html","link":"","permalink":"https://mrjerryli.github.io/post/457323eb.html","excerpt":"","text":"springboot-thymeleaf动态模板生成 thymeleaf动态模板，案例 123456789101112131415Map data = new HashMap(); data.put(\"name\", \"jerry\"); data.put(\"email\", email); data.put(\"url\", \"https://www.lijiating.online/\"); data.put(\"secondairePath\", \"myblog\"); data.put(\"requestId\", \"\");SpringTemplateEngine springTemplateEngine = new SpringTemplateEngine();StringTemplateResolver stringTemplateResolver = new StringTemplateResolver();stringTemplateResolver.setCacheable(true);stringTemplateResolver.setTemplateMode(TemplateMode.HTML); springTemplateEngine.setTemplateResolver(stringTemplateResolver)Context context = new Context();context.setVariables(data);String content = \"&lt;span th:utext=\\\"$&#123;code&#125;\\\"&gt;&lt;/span&gt;\";String result = springTemplateEngine.process(content, context); pom文件引入： 12345&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; springboot可直接引入： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://mrjerryli.github.io/tags/springboot/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"mac杀死端口","slug":"mac杀死端口","date":"2019-09-19T11:33:06.000Z","updated":"2019-09-19T11:42:16.709Z","comments":true,"path":"post/87630688.html","link":"","permalink":"https://mrjerryli.github.io/post/87630688.html","excerpt":"","text":"Mac 查看端口占用及杀死进程 查看端口占用情况 12345# jerry in ~ [14:04:53] C:1$ lsof -i :18088COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 27191 lijiating 287u IPv6 0xcebad4dccbf6e8d1 0t0 TCP *:18088 (LISTEN) 杀死占用端口的进程 12# jerry in ~ [14:05:08]$ kill -9 27191","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://mrjerryli.github.io/tags/linux/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"ZooKeeper安装及配置 for Mac","slug":"zookeeper","date":"2019-09-10T13:45:35.000Z","updated":"2019-09-10T14:21:30.996Z","comments":true,"path":"post/3ad834c9.html","link":"","permalink":"https://mrjerryli.github.io/post/3ad834c9.html","excerpt":"","text":"ZooKeeper安装及配置 for Mac 安装 查看brew info zookeeper 1234$ brew info zookeeperzookeeper: stable 3.4.12 (bottled), HEADCentralized server for distributed coordination of serviceshttps://zookeeper.apache.org/ 安装brew install zookeeper 123456789 $ brew install zookeeper ==&gt; Downloading https://homebrew.bintray.com/bottles/zookeeper-3.4.12.high_sierr###### ################################################################## 100.0%==&gt; Pouring zookeeper-3.4.12.high_sierra.bottle.tar.gz==&gt; CaveatsTo have launchd start zookeeper now and restart at login: brew services start zookeeperOr, if you don't want/need a background service you can just run: zkServer start 安装后，在/usr/local/etc/zookeeper/ 中可查看配置 1$ ls /usr/local/etc/zookeeper/ 安装后，在/usr/local/etc/zookeeper/ 已经有了缺省配置 1$ ls /usr/local/etc/zookeeper/ 查看配置文件 1$ less -N /usr/local/etc/zookeeper/zoo.cfg 配置文件如下 12345678910111213141516171819202122232425262728# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/usr/local/var/run/zookeeper/data# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to \"0\" to disable auto purge feature#autopurge.purgeInterval=1 启动服务 执行命令zkServer 1234567891011121314$ zkServerZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgUsage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;$ zkServer statusZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgError contacting service. It is probably not running.$ zkServer startZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgStarting zookeeper ... STARTED 查看zookeeper运行及状态 安装后，可以看到zookeeper提供了zkCli等工具进行. 1234567891011121314151617$ zkServer statusZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgError contacting service. It is probably not running.192:~ maerfeifei$ zkServer startZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgStarting zookeeper ... STARTED192:~ maerfeifei$ zkCliConnecting to localhost:2181Welcome to ZooKeeper!JLine support is enabledWATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: localhost:2181(CONNECTED) 0]","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://mrjerryli.github.io/tags/zookeeper/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"yarn切换镜像源","slug":"yarn","date":"2019-08-28T08:23:25.000Z","updated":"2019-08-28T08:32:36.881Z","comments":true,"path":"post/c965c636.html","link":"","permalink":"https://mrjerryli.github.io/post/c965c636.html","excerpt":"","text":"1、查看一下当前源 yarn config get registry 2、切换为淘宝源 yarn config set registry https://registry.npm.taobao.org 3、或者切换为自带的 yarn config set registry https://registry.yarnpkg.com","categories":[{"name":"yarn","slug":"yarn","permalink":"https://mrjerryli.github.io/categories/yarn/"}],"tags":[{"name":"web","slug":"web","permalink":"https://mrjerryli.github.io/tags/web/"}],"keywords":[{"name":"yarn","slug":"yarn","permalink":"https://mrjerryli.github.io/categories/yarn/"}]},{"title":"centos","slug":"centos","date":"2019-08-04T23:32:01.000Z","updated":"2019-08-11T03:39:26.557Z","comments":true,"path":"post/cd183338.html","link":"","permalink":"https://mrjerryli.github.io/post/cd183338.html","excerpt":"","text":"CentOS 7 开放3306端口访问 CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。1、关闭firewall：systemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl mask firewalld.service 2、安装iptables防火墙yum install iptables-services -y 3.启动设置防火墙 systemctl enable iptablessystemctl start iptables4.查看防火墙状态 systemctl status iptables 5编辑防火墙，增加端口vi /etc/sysconfig/iptables #编辑防火墙配置文件-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT 或者 -A INPUT -p tcp -m state –state NEW -m tcp –dport 22 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 80 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 3306 -j ACCEPT :wq! #保存退出 3.重启配置，重启系统systemctl restart iptables.service #重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mrjerryli.github.io/tags/centos/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]},{"title":"protobuf","slug":"protobuf","date":"2019-08-03T20:53:47.000Z","updated":"2019-08-11T01:39:47.195Z","comments":true,"path":"post/99fac5be.html","link":"","permalink":"https://mrjerryli.github.io/post/99fac5be.html","excerpt":"","text":"protobuf 什么是protobuf官方解释：Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. 意思是: Protocol buffers是Google的语言中立，平台中立，可扩展的机制，用于序列化结构化数据 - 类似XML，但更小，更快，更简单。 使用 Protobuf 你可以编写一次结构化数据一次，然后可以使用各种语言工具来生成对应语言的源代码然后简单的读取或者操作数据。 抓重点，语言中立， 工具，源代码 使用从上面的介绍中我们可以看到在使用 Protobuf 的使用需要有一个对应语言的工具，通过工具生成对应的源代码，然后在操作相应结构的数据。下面我们依次看下具体是如何使用的。 首先我们这里采用的是 java 语言，所以要先去下载 Java 对应的工具通过链接https://github.com/protocolbuffers/protobuf/releases/tag/v3.8.0下载 Java 的工具，macOS 可以直接使用brew install protobuf 编写 .proto 文件，在使用 Protobuf 前，我们要编写结构化的数据格式，例如我们这里编写 com-test-model-User.proto 文件 1234567891011121314//指定版本syntax = &quot;proto2&quot;;//定义包名package com.test.model;//定义结构数据message User &#123; //必选字段 第1个属性 required string name = 1; //必选字段 第2个属性 required int32 age = 2; //可选字段 第3个属性 optional string comment = 3;&#125; 编写完了采用命令protoc --java_out=. ./com-test-model-User.proto，就会在当前路径下生成相应的代码结构。 使用案例1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) throws IOException &#123; UserOuterClass.User.Builder userBuilder = UserOuterClass.User.newBuilder(); userBuilder.setName(\"子悠\"); userBuilder.setAge(18);// userBuilder.setComment(\"this is comment\"); System.out.println(\"\\n**********************序列化*****************************\"); byte[] bytes = userBuilder.build().toByteArray(); System.out.println(\"bytes length is \" + bytes.length); for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.print(bytes[i] + \" \"); &#125; System.out.println(\"\\n**********************反序列化*****************************\"); UserOuterClass.User user = UserOuterClass.User.parseFrom(bytes); System.out.println(user.getName()); &#125;&#125;//运行结果**********************序列化*****************************bytes length is 1010 6 -27 -83 -112 -26 -126 -96 16 18 **********************反序列化*****************************子悠Process finished with exit code 0 结果分析 可能到现在大家还没有发现什么优秀的地方，那么让我解释下。从运行结果来看，序列化后的是一串数字。很简短的一串数字。我们可以想一下如果这里用的 JSON 格式的序列化的话那么结果应该是{&quot;name&quot;: &quot;子悠&quot;, &quot;age&quot;: 18}，如果是 xml 的话，那就会更长，从这里我们就可以看出 protobuf 的序列化的效果是多么的强大，效率是多么的高。我们知道在网络传输的过程中，压缩效率越高传输效率就越高。 1234&lt;user&gt; &lt;name&gt;子悠&lt;/name&gt; &lt;age&gt;18&lt;/age&gt;&lt;/user&gt; protobuf 优缺点 更加简单。 数据体积小 3- 10 倍。 更快的反序列化速度，提高 20 - 100 倍。 可以自动化生成更易于编码方式使用的数据访问类。 总结 简单给大家介绍了 protobuf 的简单使用，更多的详细使用，以及底层压缩原理，感兴趣的朋友可以自己的研究一下。 另外说个题外话 protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据。 有时候就是这样，一个项目或者软件的最终形态并不是当时定义的模样，随着时间的推移产品的方向以及定位都会发生翻天覆地的变化。 附属GitHub项目demo地址","categories":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}],"tags":[{"name":"netty","slug":"netty","permalink":"https://mrjerryli.github.io/tags/netty/"},{"name":"protobuf","slug":"protobuf","permalink":"https://mrjerryli.github.io/tags/protobuf/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://mrjerryli.github.io/categories/Server/"}]}]}